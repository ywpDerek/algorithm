#### 堆结构
> 堆的具体结构表现 是 数组

假设我们遇到了数组的扩容的情况。
初始数组的长度为1，我们以成倍的方式来进行扩容。

```javascript
// 1  len: 2
// 2  len: 3
// 4  len: 5
// 8 ...
```
N 为添加了 N 次数。
从上面我们可以看出，扩容的次数为 log2N => logN
每次扩容的时间复杂度是 O(N)，我们需要新创建一个数组，然后遍历原数组，将每一项加入到新的数组中。
所以 均摊到每一个上面就是 logN * O(N) / N。
所以可以得出 heapInsert 的时间复杂度还是 O(logN)。


#### 堆排序

在进行堆排序的时候，我们首先会将 arr 变成大根堆，当用户一次性把所有的数组都给到我们的时候，为什么 heapify 会比 heapInsert 快?

#### heapInsert
```javascript
// O(N * logN)
for (let i = 0; i < arr.length; i++) {
  heapInsert(arr, i); // O(logN)
}
```
我们很容易可以看出上面的代码时间复杂度是 O(N * logN)

#### heapify
```javascript
// O(N)
for (let i = arr.length - 1; i >= 0; i--) {
  heapify(arr, i, arr.length);
}
```
上面的代码是 O(N)，推导一下：
```javascript
假设一共有 N 个数

这里我们使用满二叉树的结构，因为由此推导会比较方便
...
倒数第三      N / 8个   移动 3 次常数操作
倒数第二      N / 4个   每一个数 移动 2 次常数操作
最后一行      N / 2个   这里面每个节点就已经是大根堆了


所以 T(n) = N/2 + N/4*2 + N/8*3 + ...

T(n) = N/2 + N/4*2 + N/8*3 + ...
2T(N) = N + N/2*2 + N/4*3 + N/8*4 ...

进行错位相减可以得出
T(N) = N + N/2 + N/4 + N/8 + N/16 + ...
这是一个等比数列所以最后得出肯定是一个常数项
O(C * N) => O(N)
```
最后得出结论，如果用户一次性给出了所有的数，使用 heapify 的方式会更快!
