#### 排序总结

| 排序 | 时间复杂度 | 额外空间复杂度 | 稳定性 |
|:---:| :-----:| :----: | :----: |
| 选择排序 | O(N^2) | O(1) | 不稳定
| 冒泡排序 | O(N^2) | O(1) | 稳定
| 插入排序 | O(N^2) | O(1) | 稳定
| 归并排序 | O(N * logN) | O(N) | 稳定
| 堆排序 | O(N * logN) | O(1) | 不稳定
| 快速排序 | O(N * logN) | O(logN) | 不稳定
| 桶排序思想的排序 | O(N) | O(N) | 稳定


那我们在排序的时候到底选择什么排序？
如果我们不考虑稳定性，只追求指标最优，常数时间最优，那么我们优先选择快排，虽然堆排序、快速排序、归并排序的时间复杂度是一样的，但是经过实验，快速排序的常数项是最低的。

什么时候选择堆排序？
我们想尽量使用少的额外空间的时候。

什么时候归并？
追求稳定性的时候。

时间复杂度低于 O(N * logN)，额外空间复杂度低于 O(N)，并且稳定，目前为止还没有发现这种排序方法。所以说我们选择什么排序，完全取决于我们更想要什么？

#### 常见排序坑点
- 归并排序的额外空间复杂度可以变成 O(1)，但是非常难，不需要掌握，有兴趣可以搜 ”归并排序，内部缓存法“，但是这种方法会丧失稳定性。
- “原地归并排序” 的帖子都是垃圾，这种方法会让归并排序的额外空间复杂度变成 O(1)，并且稳定，但是会让排序的时间复杂度变成O(N^2)。
- 快速排序可以做到稳定，但是会让额外空间复杂度变成 O(N)，不如直接使用归并排序，并且非常难，不需要掌握，可以搜索 “01 stable sort”。
- 所有的改进都不重要，因为目前还没有找到时间复杂度是 O(N * logN)，额外复杂度低于 O(N)， 并且又稳定的排序。
- 有一道题，是奇数放在数组的左边，偶数放在数组的右边，还要求原始的相对次序不变，要求时间复杂度是 O(N)，额外空间复杂度是 O(1)，碰到这个问题，可以直接怼面试官，因为根本做不到。

#### 工程上对排序的改进

```javascript
// 这个方法里面会通过数组内数据的不同选择不用的排序方法
Array.sort
```
- 充分利用 O(N * logN) 和 O(N^2) 排序的各自优势
- 稳定性的考虑，比如说，当发现数组里面都是基础类型的话，那么可能直接就会使用快排，因为这个时候稳定性并不重要，如果发现不是非基础类型，可能会使用归并。

也有可能出现下面的代码
```javascript
// 我们要在 [L...R] 上面排序

// 说明中间的数小于 60
if (L > R - 60) {
  // 这个时候会进行插入排序
  // 因为在小样本中 O(N^2) 会更快
  return;
}
```


